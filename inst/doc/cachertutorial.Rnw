\documentclass{article}

%%\VignetteIndexEntry{Using the cacher Package}
%%\VignetteDepends{cacher}

\usepackage[margin=1.25in]{geometry}
\usepackage[noae]{Sweave}
\usepackage{charter}
\usepackage{courier}
\usepackage{natbib}

\newcommand{\pkg}{\texttt}
\newcommand{\code}{\texttt}

\renewcommand{\baselinestretch}{1.1}

\title{Using the \pkg{cacher} Package}

\author{Roger D. Peng $<$rpeng@jhsph.edu$>$}


\begin{document}

\maketitle


<<Setup,echo=false,results=hide>>=
.oldopt <- options()
.mypager <- function(files, header, title, delete.file = FALSE) {
        for(i in seq_along(files)) {
                f <- files[i]
                tmp <- readLines(f)
                writeLines(tmp, stdout())
        }
}
options(pager = .mypager)
.withMessages <- function(expr) {
        withCallingHandlers(expr,
                            message = function(m) {
                                    cat(conditionMessage(m))
                            })
}
options(useFancyQuotes = FALSE)
@

\section{Introduction}

The purpose of the \pkg{cacher} package is to provide tools for
``caching'' statistical analyses and for distributing these analyses
to others in an efficient manner.  Once distributed, a statistical
analysis can be reproduced, modified, or improved upon.  The
\pkg{cacher} package is an implementation of the distributed
reproducible research ideas described in~\cite{peng:ecke:2007}.

This tutorial will demonstrate how to use the \pkg{cacher} package for
caching statistical analyses and distributed these analyses over the
web.  Specifically, we will demonstrate how to create and explore a
cache database as well as download and explore cache databases created
by others.


\section{Caching Statistical Analyses}
\label{sec:statanalysis}

To illustrate some of the features of the \pkg{cacher} package we will
use the following simple statistical analysis of the \code{airquality}
dataset from the \pkg{datasets} package which comes with R.  The code
for the entire analysis is printed below.
<<ShowSampleAnalysis,echo=false>>=
writeLines(readLines("sample.R"))
@
The code is contained in a file called ``sample.R'' which comes with
the \pkg{cacher} package.  The above analysis is fairly simple and not
very time-consuming so it is easily reproduced by anyone who can run
R, without any need for caching.  Nevertheless, it is useful for
demonstrating how the \pkg{cacher} package works.

The first step is to install the \pkg{cacher} package from the
Comprehensive R Archive Network (CRAN) and load it into R.
<<LoadCacher>>=
library(cacher)
setConfig("verbose", TRUE)
@
For now, we also set the global \code{verbose} option to be
\code{TRUE}, making \code{cacher} be somewhat more ``chatty''.

The primary function is called \code{cacher} and it accepts a file
name as its first argument.  This file should contain the code for the
analysis that you want to cache.  Other arguments include the name of
the cache directory (defaults to \code{.cache}) and the name of the
log file (defaults to \code{NULL}).  If \code{logfile = NULL} then
messages will be printed to a file in the cache directory.  Setting
\code{logfile = NA} will send messages to the console.

The ``sample.R'' file containing the above analysis comes with the
\pkg{cacher} package and can be copied into your working directory.
Given a file containing the code of an analysis, you can call the
\code{cacher} function as
<<callCacher>>=
cacher("sample.R")
@
The \code{cacher} function evaluates each expression in the file and
prints any resulting output to the console.  For example, the summary
of the fitted linear model is printed to the console while the two
plots are sent to the appropriate graphics device.  The log messages
are written to a file in \code{.cache/log/sample.R.log} which
contains information about each expression evaluated by \code{cacher}.
We will discuss the contents of the log file in
Section~\ref{sec:logfile}.

When cacher evaluates each code expression, the results of the
evaluation are cached to the database and lazy-loaded back into the
workspace.  After running the ``sample.R'' analysis, we can see that
there are the following objects now in the workspace:
<<listobjects>>=
ls()
@
Since the objects are lazy-loaded, they do not occupy any memory
until they are accessed.  The lazy-loading is not as important on the
first evaluation but can reduce the amount of evaluation time required
on subsequent analysis

For example, take the following very simple set of expressions.
<<simpleanalysis,echo=false>>=
writeLines(readLines("bigvector.R"))
@
The first expression creates a vector of 1 million standard Normal
random variates and the second computes a summary (a five-number
summary plus the mean).  The amount of time to evaluate these
expressions the first time is
<<evalBigVectorFirstTime>>=
systime <- system.time(cacher("bigvector.R"))
print(systime)
@
In this case, the evaluation time is about
\Sexpr{round(as.numeric(systime[1]), 1)} seconds.  After running
\code{cacher}, the objects \code{x} and \code{s} reside in the
workspace and have been cached to the database.  Subsequent
evaluations of the same code should take much less time since we can
simply load \code{x} and \code{s} from the cache.
<<evalBigVectorSecondTime>>=
rm(x, s)
systime <- system.time(cacher("bigvector.R"))
print(systime)
@
Now the evaluation only takes about
\Sexpr{round(as.numeric(systime[1]), 3)} seconds.  In fact, the
analysis here is particularly quick because we do not need the
\code{x} vector at all.  We can simply print the summary object
\code{s}.

Even if we did need to access the vector \code{x}, loading from the
cache is often faster than regenerating all of the random Normals
using \code{rnorm}.  For example, if we wanted to calculate the 95th
percentile of the data, then we could simply do
<<calcpercentile>>=
systime <- system.time(q95 <- quantile(x, 0.95))
print(q95)
print(systime)
@


<<cleanAnalyses,echo=false,results=hide>>=
rm(list = ls())
@

\subsection{Exploring a cached analysis}


Once an analysis has been cached using \code{cacher}, it can be
explored using the utilities provided in the \pkg{cacher} package.
Since you can cache analyses from multiple files (as we have done
above), we can show which analyses have already been cached using the
\code{showfiles} function.
<<showfiles>>=
showfiles()
@
Here we see the file names corresponding to the two files that we
analyzed in the previous section.  If you want to examine a particular
analysis, you can use the \code{sourcefile} function to choose that
analysis and \code{showcode} will simply display the raw source file.
<<showCode>>=
sourcefile("bigvector.R")
showcode()
@
You can also use the \code{code} function to display the code in a
summary form
<<usingCode>>=
sourcefile("sample.R")
code()
@
The \code{code} function truncates expressions to a single line and
also shows the sequence number assigned to each expression in the
order that the expression is encountered in the source file.  In order
to see the full code for each expression, you can set the \code{full =
TRUE} option to \code{code}.

The first thing you might do when exploring a cached analysis is to
explore the elements of the cache database itself.  You can list the
objects available using the \code{showobjects} function, which returns
a character vector of the names of each object in the database.
Passing an expression sequence number to \code{showobjects} via the
\code{num} argument shows the objects created by that expression.
<<showobjects>>=
showobjects()
showobjects(8)
showobjects(1)
@
These objects can be lazy-loaded into the workspace using the
\code{loadcache} function.
<<loadcache>>=
loadcache()
ls()
@
Now, we can print the linear model fit (without actually fitting the
model) by calling
<<summarizeFit>>=
print(fit)
@
The \code{loadcache} function takes a \code{num} argument which can be
a vector of indices indicating code expression sequence numbers.  For
example, if you want to load only the objects associated with
expression 4 (i.e. the \code{fit} object), then you can call
\code{loadcache(4)}.

In addition to exploring the objects in the cache database, you may
wish to run the analysis on your own computer for the purposes of
reproducing the original results.  You can run individual expressions
or a sequence of expressions with the \code{runcode} function.  The
\code{runcode} function accepts a number or a sequence of numbers
indicating expressions in an analysis.  For example, in order to run
the first four expressions in the ``sample.R'' analysis, we could call
<<runcodeSample>>=
rm(list = ls())
code(1:4)
.withMessages( runcode(1:4) )
ls()
@
In this case, expressions 1 and 2 are evaluated but expressions 3
and 4 are loaded from the cache.  By default, \code{runcode} does not
evaluate expressions for which it can load the results from the cache.
In order to force evaluation of all expressions, you need to set the
option \code{forceAll = TRUE}.



\subsection{Understanding the log file}
\label{sec:logfile}

As each expression is being evaluated, \code{cacher} keeps track of
which expressions result in the creation of new objects (including
modification of existing objects) and which expressions have side
effects.  Expressions with side effects cannot be cached and therefore
must always be evaluated.  The primary operation falling into this
category is plotting, which launches a graphics device and makes
changes to that device.  One exception is \pkg{lattice} plots which
can be stored as objects and therefore cached.  The log file contains
information about each expression and whether it needs to force
evaluation.  Here we print the first few lines of the log file for
this analysis.

<<showlogfile,echo=false>>=
writeLines(readLines(file.path(".cache", "log", "sample.R.log"))[1:12])
@
Understanding the log file output is not critical to using
\code{cacher} but it is occasionally useful to know what the function
is doing for a given expression.  Each expression is assigned a number
based on when it is encountered in the source file and a snippet of
the expression is printed immediately after the number.  Below,
\code{cacher} will indicate if the expression needs to be evaluated
and cached and will try to determin if the expression resulted in a
side effect.  The check for side effects is rudimentary and will not
catch all cases.  Once the expression has been cached, \code{cacher}
will reload the results from the cache into the global environment
(i.e. workspace) and move to the next expression.

Running the analysis a second time with \code{cacher} results in the
following log file being generated.
<<runCacherAgain,echo=false,results=hide>>=
rm(list = ls())
cacher("sample.R")
@
<<showlogfileAgain,echo=false>>=
writeLines(readLines(file.path(".cache", "log", "sample.R.log"))[1:8])
@
Here we see that expressions 1 and 2 were forced to be evaluated
because the \code{library} function results in a side effect
(i.e. altering the search list).  Expressions 3 and 4 create objects
in the workspace so they can be lazy-loaded from the cache.  Note here
that although the \code{airquality} dataset is loaded from the cache,
it is not needed if you are primarily interested in examining the
\code{fit} object from the \code{lm} call.  This is where lazy-loading
is very useful.  However, if you want to fit a different model, say,
with some interactions, then of course the original data will be
loaded into the workspace the first time it is accessed.

\subsection{Caching Individual Expressions}

<<removeClonedCache,echo=false,results=hide>>=
unlink(".cache", recursive = TRUE)
rm(list = ls())
@

Indivdual expressions can be cached using the \code{cc} function.  For
example, you might want to cache just a single critical section of an
analysis rather than the entire analysis itself.  In this case, you
can wrap the experssion with the \code{cc} function and subsequent
evalutions of the expression will be loaded from the cache (assuming
the expression hasn't changed in the meantime).

For example, the following artificial expression takes at least 2
seconds to evaluate before the value of 5 is assigned to \code{x}.
<<cacheExampleExpr>>=
cc({
        x <- local({
                Sys.sleep(2)
                5
        })
})
@
Caching the expression with \code{cc} allows the value of \code{x}
to be loaded from the cache on subsequent evaluations.  The cache
database corresponding to this expression can be explored as in the
previous examples.
<<showCacheExpr>>=
showfiles()
@
Note that since there is no source file to use, a file name is
generated based on a digest of the expression being cached.
<<showcodeCacheExpr>>=
sourcefile(showfiles())
showcode()
@
It is probably not so useful to explore the cache associated with a
single expression.  More likely, you will want to cache an expression
so that subsequent evaluations of the same expression will be loaded
from the cache and therefore not take as long.






\section{Distributing Cached Analyses Over the Web}


<<removeCachePosting,echo=false,results=hide>>=
unlink(".cache", recursive = TRUE)
@

If you have access to a webserver you can post your cache directory
directly on the webserver for others to access.  Once made available
on a webserver, others can access your cache directory by using the
\code{clonecache} function in the \pkg{cacher} package and the URL of
the directory on your webserver.  For example, we can download the
analysis corresponding to the ``bigvector.R'' file by calling
<<clonecacheBigVector>>=
.withMessages(clonecache("http://www.biostat.jhsph.edu/rr/bigvector.cache"))
@
This call to \code{clonecache} downloads all of the relevant cache
files related to the analysis except for the cache database files.  In
order to download the cache database files, the option \code{all.files
= TRUE} must be set.

Once a cache package has been downloaded using \code{clonecache} you
can use all of the tools described in the previous sections to explore
the cache and the run some of the analyses.
<<exploreClonedURLCache>>=
showfiles()
sourcefile("bigvector.R")
code()
showobjects()
loadcache()
.withMessages(print(s))
@
By default, \code{clonecache} does not download the cache database
files until they are needed in order to minimize the amount of data
that is transferred.  Cache database files are only transferred from
the remote host when the objects associated with them are first
accessed.

In the above example, the database file corresponding to the object
\code{s} is only transferred when we call \code{print(s)}.  When a
database object has to be downloaded from the remote site, a message
will be printed to the screen indicating the transfer.


\section{Verifying a Cached Analysis}

Once you have cloned an analysis conducted by someone else, you may
wish to verify that the computation that you run on your computer
leads to the same results that the original author obtained on his/her
computer.  This can be done with the \code{checkcode} function.  The
\code{checkcode} function essentially evaluates each expression
locally (if it can) and compares the output with the corresponding
value stored in the cache database.

If the locally created object and the cached object are the same, then
that expression is considered verified.  If an expression does not
create any objects, then there is nothing to compare.  If the locally
created object and the cached object are different, the the
verification fails and \code{checkcode} will indicate which objects it
could not verify.

For example, we can run the \code{checkcode} function on the analysis
of the \code{airquality} dataset from before.  Here we will only check
the first four code expressions.
<<checkcodeSample>>=
unlink(".cache", recursive = TRUE)
.withMessages(clonecache("http://www.biostat.jhsph.edu/rr/combined.cache"))
sourcefile("sample.R")
showobjects(1:4)
.withMessages(checkcode(1:4))
@
In the first four expressions, there are two objects created: the
dataset \code{airquality} and the linear model object \code{fit}.  The
\code{checkcode} function compares each of those objects with the
version stored in the cache database (which we previously cloned from
the web).  In this case, the objects match and the computations are
verified.  Notice that in expression 3, the database file for the
\code{airquality} object had to be downloaded so that it could be
checked against the locally created version.

We can check the code in the ``bigvector.R'' analysis also.  In this
analysis there are two objects that need to be verified: \code{x}, the
vector of standard Normals and \code{s} the ``summary'' object.
<<checkcodeBigvector>>=
sourcefile("bigvector.R")
.withMessages(checkcode())
@
Notice that expressions 1 and 2 failed for a common reason
(expression 3 had no objects to verify).  Since the analysis did not
set the random number generator seed in the beginning, the generation
of the Normal random variates on the local machine is not the same as
that for the original analysis.  Therefore, the object \code{x} is not
reproducible (nor is \code{s}).

Of course, there are limitations to verifying statistical analyses.
Analyses may take a long time to run and therefore it may take a long
time to verify a given computation.  If one does not have the
necessary external resources (i.e. hardware, software) then it may not
be possible to verify an analysis at all.  Currently, verification of
analyses is limited to R objects only.  We cannot verify the output of
summary or print functions nor can we verify plots (although lattice
plots can be verified if they are stored as R objects).

Certain analyses may load external datasets or inputs which will
generally not be available to the other users.  A typical analysis
might be of the form
<<showFaithfulCode,echo=false>>=
unlink(".cache", recursive = TRUE)
rm(list = ls())
writeLines(readLines("faithful.R"))
@
This analysis reads in the the ``Old Faithful'' dataset which
contains eruption times and waiting periods for the Old Faithful
geyser in Yellowstone National Park.  Although this dataset is
available from the R installation, we have exported it here to a
comma-separated-value file for demonstration.

The original author of this analysis can run the \code{cacher}
function on this analysis file and distributed it to others.
<<cacheFaithful>>=
cacher("faithful.R")
@
However, another user (presumably on a different computer) will not be
able to verify all of the code in this analysis
<<switchDirectory,echo=false,results=hide>>=
dir.create("tmp", showWarnings = FALSE)
setwd("tmp")
clonecache("../.cache")
@
<<verifyFaithful>>=
sourcefile("faithful.R")
.withMessages(checkcode())
@
<<cleanupSwitch,echo=false,results=hide>>=
unlink(".cache", recursive = TRUE)
setwd("..")
unlink("tmp", recursive = TRUE)
@
Here, the first expression, which reads the dataset in via
\code{read.csv} cannot be verified because the ``faithful.csv'' file
is not available.  However, the other expressions can be run on the
local machine and are verifiable since they can use the cached copy of
the dataset.


\bibliography{combined}
\bibliographystyle{asa}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\section{Session Information}

<<sessionInfo,results=tex,echo=false>>=
toLatex(sessionInfo())
@




<<cleanup,echo=false,results=hide>>=
unlink(".cache", recursive = TRUE)
options(.oldopt)
@

\end{document}
